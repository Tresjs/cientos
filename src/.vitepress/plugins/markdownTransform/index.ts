import type { Plugin } from 'vite'
import { existsSync, readFileSync } from 'node:fs'
import fsPromises from 'node:fs/promises'
import path, { join, resolve } from 'node:path'
import url from 'node:url'
import { components, getComponent } from '../../../../metadata/metadata'
import matter from 'gray-matter'
import MarkdownIt from 'markdown-it'
import { parse } from 'vue/compiler-sfc'

const __dirname = path.dirname(url.fileURLToPath(import.meta.url))

const toAbsolute = (p: string) => path.resolve(__dirname, p)

const COMPONENTS_DIRECTORY = toAbsolute('../../theme/components')
const COMPONENTS_PREFIX = 'CientosCodeSnippetDemo'

export function MarkdownTransform(): Plugin {
  const DIR_TYPES = resolve(__dirname, '../../../../dist')
  const hasTypes = existsSync(DIR_TYPES)

  if (!hasTypes) { console.warn('No types dist found, run `npm run build:types` first.') }

  return {
    name: 'cientos-md-transform',
    enforce: 'pre',
    async transform(code, id) {
      if (!id.match(/\.md\b/)) { return null }
      const [pkg, _name, _] = id.split('/').slice(-3)

      const maybeComponent = components.find(c => c.docs && id.endsWith(c.docs))

      const name = maybeComponent ? maybeComponent.name : ''

      if (name) {
        const frontmatterEnds = code.indexOf('---\n\n')
        const firstHeader = code.search(/\n#{2,6}\s.+/)
        const sliceIndex = firstHeader < 0 ? frontmatterEnds < 0 ? 0 : frontmatterEnds + 4 : firstHeader

        const { footer, header } = await getComponentMarkdown(pkg, name)

        if (hasTypes) {
          code = replacer(code, footer, 'FOOTER', 'tail')
        }

        if (header) {
          code = code.slice(0, sliceIndex) + header + code.slice(sliceIndex)
        }
      }

      {
        const tokens = MarkdownIt().parse(code, {}).filter(t => t.tag === 'code' && t.info.includes('demo') && t.info.includes('vue'))
        const pieces = id.split(path.sep)
        const componentName = pieces[pieces.length - 2]
        let i = 0
        await Promise.all(tokens.map((t) => {
          const demoName = `${COMPONENTS_PREFIX}${componentName}Snippet${i++}`
          const warning = `// NOTE: Automatically generated by ${path.relative('.', __dirname)}\n// Editable source at ${path.relative('.', id)}\n// Edits here will be discarded.\n`
          const content = t.content.includes('<!-- demo-control') ? getDemoWithControls(t.content) : getDemo(t.content)
          return fsPromises.writeFile(path.join(COMPONENTS_DIRECTORY, `${demoName}.vue`), warning + content)
        }))
      }

      {
        // NOTE: Insert the demo in front of its code snippet
        const tokens = MarkdownIt().parse(code, {})
        const codeSnippetDemos = tokens.filter(token => token.tag === 'code' && token.info.includes('demo') && token.info.includes('vue'))
        const pieces = id.split(path.sep)
        const componentName = pieces[pieces.length - 2]
        for (let i = 0; i < codeSnippetDemos.length; i++) {
          const demoName = `${COMPONENTS_PREFIX}${componentName}Snippet${i}`
          code = code.replace('```vue demo', `<${demoName} />\n\`\`\`vue`)
          // NOTE: Replace demo-controls markup and leading/trailing whitespace
          code = code.replace(/\s*<!-- demo-control([\s\S]*?)-->\S*/gi, '')
        }
      }

      return code
    },
  }
}

const DIR_SRC = resolve(__dirname, '../..')
const GITHUB_BLOB_URL = 'https://github.com/Tresjs/cientos/blob/main/src'

export async function getComponentMarkdown(pkg: string, name: string) {
  const URL = `${GITHUB_BLOB_URL}/${pkg}/${name}`

  const dirname = join(DIR_SRC, pkg, name)
  const demoPath = ['demo.vue', 'demo.client.vue'].find(i => existsSync(join(dirname, i)))
  const types = await getTypeDefinition(pkg, name)

  if (!types) { console.warn(`No types found for ${pkg}/${name}`) }

  let typingSection = ''

  const positiveNOrInfinity = (n: number) => n < 0 ? Number.POSITIVE_INFINITY : n

  if (types) {
    // NOTE: Types arrive with a lot of automatically generated cruft.
    // Trim it off.
    const trimFromHere = Math.min(
      positiveNOrInfinity(types.indexOf('declare function __VLS_template(): {')),
      positiveNOrInfinity(types.indexOf('declare const _default:')),
    )
    const trimmedTypes = types.trim().substring(0, trimFromHere)

    const code = `\`\`\`typescript\n${trimmedTypes}\n\`\`\``
    typingSection = `\n## Type Declarations\n\n${code}`
  }

  const links = ([
    ['Source', `${URL}/index.ts`],
    demoPath ? ['Demo', `${URL}/${demoPath}`] : undefined,
    ['Docs', `${URL}/index.md`],
  ])
    .filter(i => i)
    .map(i => `[${i![0]}](${i![1]})`)
    .join(' • ')

  const sourceSection = `## Source\n\n${links}\n`

  const footer = `${typingSection}\n\n${sourceSection}\n`

  return {
    header: '',
    footer,
  }
}

function replacer(code: string, value: string, key: string, insert: 'head' | 'tail' | 'none' = 'none') {
  const START = `<!--${key}_STARTS-->`
  const END = `<!--${key}_ENDS-->`
  const regex = new RegExp(`${START}[\\s\\S]*?${END}`, 'im')

  const target = value ? `${START}\n\n${value.trim()}\n\n${END}` : `${START}${END}`

  if (!code.match(regex)) {
    if (insert === 'none') { return code }
    else if (insert === 'head') { return `${target}\n\n${code}` }
    else { return `${code}\n\n${target}` }
  }

  return code.replace(regex, target)
}

async function getTypeDefinition(pkg: string, name: string): Promise<string | undefined> {
  const component = getComponent(name)
  if (!component) { return }

  const DIR_DTS = resolve(__dirname, '../../../../dist')
  const FILE_DTS = join(DIR_DTS, `${component.path}/component.vue.d.ts`)

  if (!existsSync(FILE_DTS)) { return }

  let types = readFileSync(FILE_DTS, 'utf-8')

  // NOTE: clean up types
  types = types
    .replace(/import\(.*?\)\./g, '')
    .replace(/import[\s\S]+?from ?["'][\s\S]+?["']/g, '')
    .replace(/export \{\}/g, '')

  const prettier = await import('prettier')
  return (await prettier
    .format(
      types,
      {
        semi: false,
        parser: 'typescript',
      },
    ))
    .trim()
}

function getDemo(srcText: string): string {
  const { script, scriptSetup, template } = parse(srcText).descriptor

  const scriptSetupOut = `<script setup lang="${scriptSetup?.lang ?? 'ts'}">
import DocsDemo from './DocsDemo.vue'${scriptSetup?.content ?? ''}
</script>\n\n`

  const scriptOut = script
    ? `<script setup lang="${script.lang}">
${script.content}
</script>\n\n`
    : ''

  const templateOut = template
    ? `<template>
<DocsDemo>${template.content}</DocsDemo>
</template>
`
    : ''

  return `${scriptSetupOut}${scriptOut}${templateOut}`
}

function getDemoWithControls(srcText: string): string {
  const { script, scriptSetup, template } = parse(srcText).descriptor
  if (!template) { return srcText }
  // NOTE: Descend through template AST to find control definition
  // nodes and the props they should control
  const openAstNodes = [template.ast] as unknown as { source: string, type: number, children?: any[], loc?: { source: string }, props?: any[] }[]
  const openControlInfos = [] as ReturnType<typeof parseControlDefinition>
  let controlInfos = []
  while (openAstNodes.length) {
    const astNode = openAstNodes.shift()!
    for (const child of astNode.children ?? []) {
      openAstNodes.push(child)
    }
    if (astNode.loc?.source?.startsWith('<!-- demo-control')) {
      const controlInfo = parseControlDefinition(astNode.loc.source)
      if (controlInfo.propName) {
        openControlInfos.push(controlInfo)
      }
      else {
        console.warn('[Cientos markdownTransform] controlDefinition must include a propName.')
      }
    }
    else if (astNode.type !== 3 && openControlInfos.length) {
      // NOTE: node.type indicates this node is not a comment (type 3) – so not a control.
      // And we have one or more control definitions to pair with this node.
      // Try to apply the controls to this node
      while (openControlInfos.length) {
        const controlInfo = openControlInfos.shift()
        const propName = controlInfo.propName
        const prop = astNode.props ? astNode.props.filter(p => [p.rawName, p.name].includes(propName) || [p.rawName, p.name].includes(`:${propName}`))[0] : null
        if (prop) {
          controlInfo.node = astNode
          controlInfo.prop = prop
          controlInfos.push(controlInfo)
        }
        else if (!astNode.props) {
          console.warn(`[Cientos markdownTransform] control definition for '${propName}' was dropped. No props found on following node.`)
        }
        else {
          console.warn(`[Cientos markdownTransform] control definition for '${propName}' was dropped. '${propName}' not found in:\n${astNode.props.map(p => p.rawName ?? p.name).join(', ')}`)
        }
      }
    }
  }

  // NOTE: Remove any controlInfos we didn't find
  controlInfos = controlInfos.filter(c => c.node !== null)

  // NOTE: Sort controlsInfos in descending order of char offset. Descending
  // order allows us to replace 'abc' with 'abcde' or 'ab' without needing
  // to recalculate the remaining offsets.
  const controlInfosByCharOffsetDec = [...controlInfos].sort((a, b) => b.prop.loc.start.offset - a.prop.loc.start.offset)
  let templateStr = template.content
  controlInfosByCharOffsetDec.forEach((c, i) => {
    // NOTE: Replace controlled prop's value with a ref
    c.refName = `demoControlRef${i}`
    // NOTE: Replace value in `template` with refName
    const startI = c.prop.loc.start.offset - template.loc.start.offset
    const start = templateStr.substring(0, startI)
    const endI = c.prop.loc.end.offset - template.loc.start.offset
    const end = templateStr.substring(endI)
    const propName = c.prop.rawName ?? c.prop.name
    const prefix = (propName.startsWith('v-') || propName.startsWith(':')) ? '' : ':'
    const propString = `${prefix}${propName}="${c.refName}"`
    templateStr = `${start}${propString}${end}`
  })

  const controlsComponents: string[] = []
  const controlsRefs: string[] = []
  const controlsImportsSet = new Set<string>()
  controlInfos.forEach((c) => {
    const controlType: 'color' | 'select' | 'text' | 'range' | 'checkbox' | 'vector3' = (() => {
      if ('type' in c) { return c.type }
      if (typeof c.value === 'string' && c.value.startsWith('#')) { return 'color' }
      if (typeof c.value === 'string' && 'options' in c) { return 'select' }
      if (typeof c.value === 'string') { return 'text' }
      if (typeof c.value === 'number') { return 'range' }
      if (typeof c.value === 'boolean') { return 'checkbox' }
      if (Array.isArray(c.value) && c.value.length === 3 && c.value.every((n: unknown) => typeof n === 'number')) { return 'vector3' }
      return null
    })()

    if (controlType === null) { return }

    const rawLabel = c.label ?? c.prop.rawName ?? c.prop.name
    // NOTE: Normalize labels for UI by removing initial ':', if one exists.
    const label = rawLabel.startsWith(':') ? rawLabel.substring(1) : rawLabel
    const start = `<DocsDemoControl label="${label}">\n`
    const end = `\n</DocsDemoControl>`

    if (controlType === 'checkbox') {
      controlsImportsSet.add('import DocsDemoCheckbox from \'./DocsDemoCheckbox.vue\'')
      controlsComponents.push(`${start}<DocsDemoCheckbox :value="${c.refName}" @change="(v)=>{ ${c.refName} = v }" />${end}`)
      controlsRefs.push(`const ${c.refName} = demoRef(${c.value})`)
    }
    else if (controlType === 'text') {
      controlsImportsSet.add('import DocsDemoText from \'./DocsDemoText.vue\'')
      controlsComponents.push(`${start}<DocsDemoText :value="${c.refName}" @change="(v)=>{ ${c.refName} = v }" />${end}`)
      controlsRefs.push(`const ${c.refName} = demoRef('${c.value}')`)
    }
    else if (controlType === 'color') {
      controlsImportsSet.add('import DocsDemoColor from \'./DocsDemoColor.vue\'')
      controlsComponents.push(`${start}<DocsDemoColor :value="${c.refName}" @change="(v)=>{ ${c.refName} = v }" />${end}`)
      controlsRefs.push(`const ${c.refName} = demoRef('${c.value}')`)
    }
    else if (controlType === 'select') {
      controlsImportsSet.add('import DocsDemoSelect from \'./DocsDemoSelect.vue\'')
      const options = Array.isArray(c.options) ? c.options.map((v: unknown) => typeof v === 'string' ? `'${v}'` : v) : c.options
      controlsComponents.push(`${start}<DocsDemoSelect :options="[${options}]" :value="${c.refName}" @change="(v)=>{ ${c.refName} = v }" />${end}`)
      controlsRefs.push(`const ${c.refName} = demoRef('${c.value}')`)
    }
    else if (controlType === 'range') {
      controlsImportsSet.add('import DocsDemoRange from \'./DocsDemoRange.vue\'')
      const min = typeof c.min === 'undefined' ? '' : `:min="${c.min}" `
      const max = typeof c.max === 'undefined' ? '' : `:max="${c.max}" `
      controlsComponents.push(`${start}<DocsDemoRange ${min}${max}:step="${c.step ?? 0.01}" :value="${c.refName}" @change="(v)=>{ ${c.refName} = v }" />${end}`)
      controlsRefs.push(`const ${c.refName} = demoRef(${c.value})`)
    }
    else if (controlType === 'vector3') {
      controlsImportsSet.add('import DocsDemoRangeVector3 from \'./DocsDemoRangeVector3.vue\'')
      const min = typeof c.min === 'undefined' ? '' : `:min="${c.min}" `
      const max = typeof c.max === 'undefined' ? '' : `:max="${c.max}" `
      controlsComponents.push(`${start}<DocsDemoRangeVector3 ${min}${max}:step="${c.step ?? 0.01}" :value="${c.refName}" @change="(v)=>{ ${c.refName} = v }" />${end}`)
      controlsRefs.push(`const ${c.refName} = demoRef<[number, number, number]>([${c.value}])`)
    }
  })

  const scriptSetupOut = `<script setup lang="${scriptSetup?.lang ?? 'ts'}">
import { ref as demoRef } from 'vue'${scriptSetup?.content ?? ''}
import DocsDemoWithControls from './DocsDemoWithControls.vue'
${Array.from(controlsImportsSet).join('\n')}

${controlsRefs.join('\n')}
</script>\n\n`

  const scriptOut = script
    ? `<script setup lang="${script.lang}">
${script.content}
</script>\n\n`
    : ''

  const templateOut = template
    ? `<template>
<DocsDemoWithControls>${templateStr}</DocsDemoWithControls>
  <div>
${controlsComponents.join('\n    ')}
  </div>
</template>
`
    : ''

  return `${scriptSetupOut}${scriptOut}${templateOut}`
}

function parseControlDefinition(definitionString: string) {
  const childSourceAsFrontmatter = definitionString.split('\n').map((s: string) => s.trim()).join('\n').replace('<!-- demo-control', '---\npropName: ').replace('-->', '---')
  const controlInfo = matter(childSourceAsFrontmatter).data
  return controlInfo
}
