import { basename, join, parse, relative, resolve, sep } from 'node:path'
import * as fs from 'node:fs/promises'
import * as fsSync from 'node:fs'
import { fileURLToPath } from 'node:url'
import type { CientosComponent, CientosPackage, PackageIndexes } from '../metadata/types'
import matter from 'gray-matter'

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const DIR_ROOT = resolve(__dirname, '..')
const DIR_PLAYGROUND = resolve(DIR_ROOT, 'playground/vue/src')
const PATH_PLAYGROUND_ROUTER = resolve(DIR_PLAYGROUND, 'router.ts')
const DIR_SRC = resolve(DIR_ROOT, 'src')

export async function updateImport({ components }: PackageIndexes) {
  const DIR = 'src'
  const imports = [] as string[]
  const exports = [] as string[]

  for (const c of components) {
    console.log(c)
    if (c.component) {
      imports.push(`import ${c.name} from './${relative(DIR, c.component)}'`)
      exports.push(`  ${c.name},`)
      for (const alias of (c.alias ?? [])) { exports.push(`  ${c.name} as ${alias},`) }
    }
    if (c.fn) {
      const fnName = `use${c.name}`
      const pieces = parse(relative(DIR, c.fn))
      const filePath = `.${sep}${join(pieces.dir, pieces.name)}`
      imports.push(`import { ${fnName} } from '${filePath}'`)
      exports.push(`  ${fnName},`)
      for (const alias of (c.alias ?? [])) { exports.push(`  ${fnName} as use${alias},`) }
    }
  }

  const data = `// NOTE: Generated by ${relative('.', __dirname)}
// Do not make edits here - they will be overwritten.
${imports.sort().join('\n')}

export {
${exports.sort().join('\n')}
}
`

  await fs.writeFile(join(DIR, 'index.ts'), data)
}

export async function updatePlaygroundRoutes({ components }: PackageIndexes) {
  const imports = [] as string[]
  const routes = [] as string[]
  const PLAYGROUND_PATH_RE = /.*playground(.*).vue$/

  let i = 0
  for (const c of components) {
    if (!c.playgrounds) { continue }
    for (const playground of c.playgrounds) {
      const [isMatch, suffix] = playground.match(PLAYGROUND_PATH_RE) ?? [null, '']
      if (!isMatch) { continue }
      const path = suffix ? sep + join(c.package, c.name, suffix) : sep + join(c.package, c.name)
      const name = suffix ? `${c.name} ${suffix}` : c.name
      const importedName = `P${String(i++).padStart(3, '0')}`

      imports.push(`import ${importedName} from './${relative(DIR_PLAYGROUND, playground)}'`)
      routes.push(
        `  {
    path: '${path}',
    name: '${name}',
    component: ${importedName},
    category: '${c.category}',
  }`,
      )
    }
  }

  const data = `// NOTE: Generated by ${relative('.', __dirname)}
// Do not make edits here - they will be overwritten.
import { createRouter, createWebHistory } from 'vue-router'

import Home from './pages/index.vue'
${imports.join('\n')}

export const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
  },
${routes.join(',\n')},
]

export const router = createRouter({
  history: createWebHistory(),
  routes,
})
`

  await fs.writeFile(PATH_PLAYGROUND_ROUTER, data)
}

/////////////////////////////////////////////////////

export async function updateMetadata(): Promise<PackageIndexes> {
  const ALLOWED_CATEGORIES = new Set(['abstractions', 'controls', 'loaders', 'materials', 'misc', 'shapes', 'staging'])
  const input = getInput()
  await canAccess(input)
  getComponents(input)
  getPackageIndexes(input)
  write(input)
  return input.packageIndexes

  interface Input {
    PACKAGE_DIR: string
    BASE_DIR: string
    packages: Record<CientosPackage['name'], CientosPackage>
    packageIndexes: PackageIndexes
  }

  function getInput() {
    return {
      PACKAGE_DIR: resolve('metadata'),
      BASE_DIR: resolve('.'),
      packages: {} as Record<CientosPackage['name'], CientosPackage>,
      packageIndexes: {} as PackageIndexes,
    }
  }

  function canAccess(input: Input) {
    return fs.access(input.BASE_DIR, fs.constants.R_OK | fs.constants.W_OK)
      .then(() => input)
  }

  function getComponents(input: Input) {
    const packageDirs = fsSync.globSync(join(DIR_SRC, '*')).map(p => relative(DIR_ROOT, p))

    for (const DIR_PACKAGE of packageDirs) {
      if (DIR_PACKAGE.includes('.')) { continue }
      const packageName = DIR_PACKAGE.split(sep).pop()!
      const _package = {
        name: packageName,
        dir: relative(DIR_ROOT, DIR_PACKAGE),
        categories: [] as string[],
        components: [] as CientosComponent[],
      }

      input.packages[packageName] = _package

      const componentFiles = new Set(fsSync.globSync(join(DIR_PACKAGE, '*/*.*')))
      const componentMds = fsSync.globSync(join(DIR_PACKAGE, '*/index.md'))
      const componentDirectories = componentMds.map(p => p.split(sep).slice(0, -1).join(sep))
      componentDirectories.sort()

      _package.components = componentDirectories.map((componentDirectory) => {
        const PATH_COMPONENT = join(componentDirectory, 'component.vue')
        const PATH_USE_FN = join(componentDirectory, 'index.ts')
        const PATH_PLAYGROUND_RE = new RegExp(join(componentDirectory, 'playground(.*).vue'))
        const PATH_MD = join(componentDirectory, 'index.md')

        const mdRaw = fsSync.readFileSync(PATH_MD, 'utf-8')
        const { data: frontmatter } = matter(mdRaw)

        const playgroundPaths: string[] = []
        for (const componentFile of componentFiles) {
          if (componentFile.match(PATH_PLAYGROUND_RE)) {
            playgroundPaths.push(componentFile)
          }
        }

        if (!componentFiles.has(PATH_COMPONENT)) {
          const msg = `${componentDirectory} does not contain a 'component.vue'`
          throw new Error(msg)
        }

        if (Object.keys(frontmatter).length === 0) {
          const exampleCategory = Array.from(ALLOWED_CATEGORIES)[0]
          const msg = `${PATH_MD} must contain markdown frontmatter. E.g.\n---\ncategory: ${exampleCategory}\n---`
          throw new Error(msg)
        }

        if (!frontmatter.category) {
          const exampleCategory = Array.from(ALLOWED_CATEGORIES)[0]
          const msg = `${PATH_MD} frontmatter must contain a category. E.g.\n---\ncategory: ${exampleCategory}\n---`
          throw new Error(msg)
        }

        if (!ALLOWED_CATEGORIES.has(frontmatter.category)) {
          const msg = `${PATH_MD}\nFrontmatter category '${frontmatter.category}' is not in allowed categories.\nThis is probably a typo.\nAllowed categories: ${Array.from(ALLOWED_CATEGORIES).map(s => `"${s}"`).join(', ')}`
          throw new Error(msg)
        }

        const component: CientosComponent = {
          name: basename(componentDirectory),
          docs: PATH_MD,
          path: componentDirectory,
          package: packageName,
          category: frontmatter.category,
          component: PATH_COMPONENT,
        }

        if (componentFiles.has(PATH_USE_FN)) { component.fn = PATH_USE_FN }

        if (playgroundPaths.length) { component.playgrounds = playgroundPaths }
        if (frontmatter.alias) { component.alias = frontmatter.alias.split(',').map(a => a.trim()) }
        if (frontmatter.deprecated) { component.deprecated = true }
        if (frontmatter.related) { component.related = frontmatter.related }

        return component
      })

      _package.categories = Array.from(_package.components.reduce((s, c) => { s.add(c.category); return s }, new Set<string>()))
    }

    return input
  }

  function getPackageIndexes(input: Input) {
    const categories = new Set<string>()
    const components = [] as CientosComponent[]
    for (const p of Object.values(input.packages)) {
      for (const category of p.categories) {
        categories.add(category)
      }
      for (const component of p.components) {
        components.push(component)
      }
    }

    input.packageIndexes = {
      packages: input.packages,
      categories: Array.from(categories),
      components,
    }

    return input
  }

  function write(input: Input) {
    const fileName = join(input.PACKAGE_DIR, 'index.json')
    const data = `${JSON.stringify(input.packageIndexes, null, 2)}\n`
    fsSync.writeFileSync(fileName, data)

    return input
  }
}
