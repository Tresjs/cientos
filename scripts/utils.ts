import { basename, join, relative, resolve, sep } from 'node:path'
import * as fs from 'node:fs/promises'
import * as fsSync from 'node:fs'
import { fileURLToPath } from 'node:url'
import type { CientosComponent, CientosPackage, PackageIndexes } from '../metadata/types'
import matter from 'gray-matter'

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const DIR_ROOT = resolve(__dirname, '..')
const DIR_PLAYGROUND = resolve(DIR_ROOT, 'playground/vue/src')
const PATH_PLAYGROUND_ROUTER = resolve(DIR_PLAYGROUND, 'router.ts')
const DIR_SRC = resolve(DIR_ROOT, 'src')

export async function updateImport({ packages, components }: PackageIndexes) {
  for (const { name, dir } of Object.values(packages)) {
    const imports = components
      .filter(component => component.package === name && component.component.endsWith('.vue'))
      .map(component => `import ${component.name} from './${relative(dir, component.component)}'`)
      .sort((a, b) => a.localeCompare(b))

    const exports = components
      .filter(component => component.package === name && component.component.endsWith('.vue'))
      .map(component => component.name)
      .sort((a, b) => a.localeCompare(b))

    const data = `// NOTE: Generated by scripts/utils/updateImport
// Do not make edits here - they will be overwritten.
${imports.join('\n')}

export {
${exports.map(s => `  ${s}`).join(',\n')},
}
`

    await fs.writeFile(join(dir, 'index.ts'), data)
  }
}

export async function updatePlaygroundRoutes({ components }: PackageIndexes) {
  const imports = [] as string[]
  const routes = [] as string[]
  for (const c of components) {
    if (!c.playground) { continue }
    const playgroundName = `${c.name}Playground`

    imports.push(`import ${playgroundName} from './${relative(DIR_PLAYGROUND, c.playground)}'`)

    routes.push(
      `  {
    path: '/${c.package}/${c.name}',
    name: '${c.name}',
    component: ${playgroundName},
  }`,
    )
  }

  const data = `// NOTE: Generated by scripts/utils/updatePlaygroundRoutes
// Do not make edits here - they will be overwritten.
import { createRouter, createWebHistory } from 'vue-router'

import Home from './pages/index.vue'
${imports.join('\n')}

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
  },
${routes.join(',\n')},
]

export const router = createRouter({
  history: createWebHistory(),
  routes,
})
`

  await fs.writeFile(PATH_PLAYGROUND_ROUTER, data)
}

/////////////////////////////////////////////////////

export async function updateMetadata(): Promise<PackageIndexes> {
  const ALLOWED_CATEGORIES = new Set(['abstractions', 'controls', 'loaders', 'materials', 'misc', 'shapes', 'staging'])
  const input = getInput()
  await canAccess(input)
  getComponents(input)
  getPackageIndexes(input)
  await write(input)
  return input.packageIndexes

  interface Input {
    PACKAGE_DIR: string
    BASE_DIR: string
    packages: Record<CientosPackage['name'], CientosPackage>
    packageIndexes: PackageIndexes
  }

  function getInput() {
    return {
      PACKAGE_DIR: resolve('metadata'),
      BASE_DIR: resolve('.'),
      packages: {} as Record<CientosPackage['name'], CientosPackage>,
      packageIndexes: {} as PackageIndexes,
    }
  }

  function canAccess(input: Input) {
    return fs.access(input.BASE_DIR, fs.constants.R_OK | fs.constants.W_OK)
      .then(() => input)
  }

  function getComponents(input: Input) {
    const packageDirs = fsSync.globSync(join(DIR_SRC, '*')).map(p => relative(DIR_ROOT, p))

    for (const DIR_PACKAGE of packageDirs) {
      if (DIR_PACKAGE.includes('.')) { continue }
      const packageName = DIR_PACKAGE.split(sep).pop()!
      const _package = {
        name: packageName,
        dir: relative(DIR_ROOT, DIR_PACKAGE),
        categories: [] as string[],
        components: [] as CientosComponent[],
      }

      input.packages[packageName] = _package

      const componentFiles = new Set(fsSync.globSync(join(DIR_PACKAGE, '*/*.*')))
      const componentMds = fsSync.globSync(join(DIR_PACKAGE, '*/index.md'))
      const componentDirectories = componentMds.map(p => p.split(sep).slice(0, -1).join(sep))
      componentDirectories.sort()

      _package.components = componentDirectories.map((componentDirectory) => {
        const PATH_COMPONENT = join(componentDirectory, 'component.vue')
        const PATH_PLAYGROUND = join(componentDirectory, 'playground.vue')
        const PATH_MD = join(componentDirectory, 'index.md')

        const mdRaw = fsSync.readFileSync(PATH_MD, 'utf-8')
        const { data: frontmatter } = matter(mdRaw)

        if (!componentFiles.has(PATH_COMPONENT)) {
          const msg = `${componentDirectory} does not contain a 'component.vue'`
          throw new Error(msg)
        }

        if (!frontmatter.category) {
          const exampleCategory = Array.from(ALLOWED_CATEGORIES)[0]
          const msg = `${PATH_MD} frontmatter must contain a category. E.g.\n---\ncategory: ${exampleCategory}\n---`
          throw new Error(msg)
        }

        if (!ALLOWED_CATEGORIES.has(frontmatter.category)) {
          const msg = `${PATH_MD}\nFrontmatter category '${frontmatter.category}' is not in allowed categories.\nThis is probably a typo.\nAllowed categories: ${Array.from(ALLOWED_CATEGORIES).map(s => `"${s}"`).join(', ')}`
          throw new Error(msg)
        }

        const component: CientosComponent = {
          name: basename(componentDirectory),
          path: componentDirectory,
          package: packageName,
          category: frontmatter.category,
          component: PATH_COMPONENT,
          docs: PATH_MD,
        }

        if (componentFiles.has(PATH_PLAYGROUND)) { component.playground = PATH_PLAYGROUND }
        if (frontmatter.deprecated) { component.deprecated = true }
        if (frontmatter.related) { component.related = frontmatter.related }

        return component
      })

      _package.categories = Array.from(_package.components.reduce((s, c) => { s.add(c.category); return s }, new Set<string>()))
    }

    return input
  }

  function getPackageIndexes(input: Input) {
    const categories = new Set<string>()
    const components = [] as CientosComponent[]
    for (const p of Object.values(input.packages)) {
      for (const category of p.categories) {
        categories.add(category)
      }
      for (const component of p.components) {
        components.push(component)
      }
    }

    input.packageIndexes = {
      packages: input.packages,
      categories: Array.from(categories),
      components,
    }

    return input
  }

  function write(input: Input) {
    const fileName = join(input.PACKAGE_DIR, 'index.json')
    const data = `${JSON.stringify(input.packageIndexes, null, 2)}\n`
    fsSync.writeFileSync(fileName, data)

    return input
  }
}
